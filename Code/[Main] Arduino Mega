#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_ADXL345_U.h>

Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified(12345);

// 센서 및 릴레이 핀 정의
const int pressureSensor = A0;
const int safetyBeltSwitch = 2;
const int tiltSensor = 3;
const int accelSensor = A1;
const int lightSensor = A2;
const int speedSensor = 4;
const int ultrasonicTrigger = 5;
const int ultrasonicEcho = 6;
const int ledPin = 15;

const int relay1 = 7;
const int relay2 = 8;
const int relay3 = 9;
const int relay4 = 10;
const int relay5 = 11;
const int relay6 = 12;
const int relay7 = 13;
const int relay8 = 14;

const float wheelDiameter = 0.5;  // 바퀴 지름 (미터)
const float wheelCircumference = wheelDiameter * 3.14159;
const int thresholdAngle = 10;  // 기울기 임계값 (도)
const int thresholdSpeed = 10;  // 속도 임계값 (km/h)

// 속도 측정 변수
unsigned long prevMillis = 0;
float currentSpeed = 0;

void setup() {
  Serial.begin(9600);
  Wire.begin();
  if (!accel.begin()) {
    Serial.println("가속도 센서 인식 실패");
    while (1)
      ;
  }

  pinMode(pressureSensor, INPUT);
  pinMode(safetyBeltSwitch, INPUT);
  pinMode(tiltSensor, INPUT);
  pinMode(speedSensor, INPUT);
  pinMode(accelSensor, INPUT);
  pinMode(lightSensor, INPUT);
  pinMode(ultrasonicTrigger, OUTPUT);
  pinMode(ultrasonicEcho, INPUT);

  for (int i = relay1; i <= relay8; i++) {
    pinMode(i, OUTPUT);
    digitalWrite(i, LOW);
  }

  pinMode(ledPin, OUTPUT);
  digitalWrite(ledPin, LOW);
}

void loop() {
  checkSafety();

  adjustWheelchairAngle();
  detectFallAndSendAlert();
  controlAutoLight();
  detectObstacleAndStop();
  detectOverspeedAndStop();

  printDebugInfo();
}

// 압력 센서 및 안전벨트 스위치 확인 함수
void checkSafety() {
  if (digitalRead(pressureSensor) == LOW || digitalRead(safetyBeltSwitch) == LOW) {
    applyBrakes();
  } else {
    releaseBrakes();
  }
}

// 경사로 기울기 조절 함수
void adjustWheelchairAngle() {
  bool isUphill = digitalRead(tiltSensor);
  int rawAccelValue = analogRead(accelSensor);
  int filteredAccelValue = filterNoise(rawAccelValue);
  int angle = calculateAngle(filteredAccelValue);

  if (angle > thresholdAngle) {
    if (isUphill) {
      retractFrontWheels();
    } else {
      extendFrontWheels();
    }
  }
}

// 가속도 센서 값에서 기울기 각도 계산 함수
int calculateAngle(int filteredAccelValue) {
  sensors_event_t event;
  accel.getEvent(&event);
  float x_accel = event.acceleration.x;

  float angle = atan2(x_accel, sqrt(pow(event.acceleration.y, 2) + pow(event.acceleration.z, 2))) * 180.0 / PI;
  return angle;
}

// 넘어짐 감지 및 자동 신고 함수
void detectFallAndSendAlert() {
  bool isTilted = digitalRead(tiltSensor);
  int rawAccelValue = analogRead(accelSensor);
  int filteredAccelValue = filterNoise(rawAccelValue);
  int angle = calculateAngle(filteredAccelValue);

  if (isTilted && angle > 90) {
    sendEmergencyAlert(1);
  }
}

// 오토 라이트 제어 함수
void controlAutoLight() {
  int rawLightValue = analogRead(lightSensor);
  int filteredLightValue = filterNoise(rawLightValue);
  if (filteredLightValue < 100) {
    digitalWrite(ledPin, HIGH);
  } else {
    digitalWrite(ledPin, LOW);
  }
}

// 장애물 감지 및 충돌 방지/긴급 정지 함수
void detectObstacleAndStop() {
  long distance = measureDistance();

  if (distance < 50) {
    applyBrakes();
  } else {
    releaseBrakes();
  }
}

// 과속 감지 및 긴급 정지 함수
void detectOverspeedAndStop() {
  measureSpeed();

  if (currentSpeed > thresholdSpeed) {
    applyBrakes();
  } else {
    releaseBrakes();
  }
}

// 노이즈 필터링 함수
int filterNoise(int rawValue) {
  static int values[10];
  static int index = 0;
  static int sum = 0;

  sum -= values[index];
  values[index] = rawValue;
  sum += values[index];

  index = (index + 1) % 10;

  return sum / 10;
}

// 앞바퀴 길이 확장 함수
void extendFrontWheels() {
  digitalWrite(relay1, HIGH);
  digitalWrite(relay2, LOW);
  digitalWrite(relay3, HIGH);
  digitalWrite(relay4, LOW);
}

// 앞바퀴 길이 축소 함수
void retractFrontWheels() {
  digitalWrite(relay1, LOW);
  digitalWrite(relay2, HIGH);
  digitalWrite(relay3, LOW);
  digitalWrite(relay4, HIGH);
}

// 브레이크 적용 함수
void applyBrakes() {
  digitalWrite(relay5, HIGH);
  digitalWrite(relay6, LOW);
  digitalWrite(relay7, HIGH);
  digitalWrite(relay8, LOW);
}

// 브레이크 해제 함수
void releaseBrakes() {
  digitalWrite(relay5, LOW);
  digitalWrite(relay6, HIGH);
  digitalWrite(relay7, LOW);
  digitalWrite(relay8, HIGH);
}

// 거리 측정 함수
long measureDistance() {
  digitalWrite(ultrasonicTrigger, LOW);
  delayMicroseconds(2);
  digitalWrite(ultrasonicTrigger, HIGH);
  delayMicroseconds(10);
  digitalWrite(ultrasonicTrigger, LOW);

  long duration = pulseIn(ultrasonicEcho, HIGH);
  long distance = (duration / 2) / 29.1;

  return distance;
}

// 속도 측정 함수
void measureSpeed() {
  unsigned long currentMillis = millis();

  if (digitalRead(speedSensor) == HIGH && prevMillis == 0) {
    prevMillis = currentMillis;
  } else if (digitalRead(speedSensor) == LOW && prevMillis > 0) {
    unsigned long timeElapsed = currentMillis - prevMillis;
    float speed = (wheelCircumference / timeElapsed) * 1000;  // m/s로 변환
    currentSpeed = speed;
    prevMillis = 0;
  }
}

// 비상 경보 전송 함수
void sendEmergencyAlert(bool felldown) {
  float gpsLocation[2] = {0,0};
  String message;
  String sum;
  char sLatF[15];
  char sLongF[15];
  dtostrf(gpsLocation[0],11,6,sLatF);
  dtostrf(gpsLocation[1],11,6,sLongF);
  if(felldown){
    sum = "T,";
  }
  else{
    sum = "F,";
  }
  sum += sLatF;
  sum += ",";
  sum += sLongF;
  //sum += ",";
  message = sum.length();
  message += ",";
  message += sum;
  Serial.println(message);
  sendMessage(message);
}

void sendMessage(String message){ //미니보드 전송
  Wire.beginTransmission(1);
  Wire.write(message.c_str());
  Wire.endTransmission(1);
}

// 테스트 및 디버깅을 위한 시리얼 출력 함수
void printDebugInfo() {
  Serial.print("압력 센서: ");
  Serial.println(digitalRead(pressureSensor));
  Serial.print("안전벨트 스위치: ");
  Serial.println(digitalRead(safetyBeltSwitch));
  Serial.print("기울기 센서: ");
  Serial.println(digitalRead(tiltSensor));
  Serial.print("가속도 센서: ");
  Serial.println(analogRead(accelSensor));
  Serial.print("조도 센서: ");
  Serial.println(analogRead(lightSensor));
  Serial.print("속도 센서: ");
  Serial.println(digitalRead(speedSensor));
  Serial.print("거리: ");
  Serial.println(measureDistance());
  Serial.print("속도: ");
  Serial.println(currentSpeed);
  delay(1000);
}
